\chapter{Imlement algorithm for training weigths for vector association measure}

\section{Algorithms implemented in MeWeX}
MeWeX contains several algorithms which were implemented by Łukasz Kłyk in his \(Optimizer\) and adopted by 
Michał Wendelberger.


% Wagi rankingów to parametry algorytmu kombinacji, które powinny zostać wyznaczone eks-
% perymentalnie, na przykład poprzez ich optymalizację. Prezentowane oprogramowanie umożli-
% wia wykorzystanie do tego celu pięciu różnych algorytmów heurystycznych i metaheurystycz-
% nych implementacji Łukasza Kłyka [13]. Utworzony przez niego Optimizer został przystoso-
% wany przez autora niniejszej pracy do działania z opisywanym MWeXtractorem. Łukasz Kłyk
% zaimplementował następujące algorytmy w swoim oprogramowaniu:

% Nazwy wspomnianych algorytmów heurystycznych i metaheurystycznych dokładnie określa-
% ją, jakie są to algorytmy, jednak poza dwoma wyjątkami – symulowanym wyżarzaniem i algoryt-
% mem ewolucyjnym. Pierwszy z nich nie precyzuje schematu chłodzenia, ale domyślnie w opro-
% gramowaniu zaimplementowanym przez Łukasza Kłyka stosowana jest funkcja T (k) = 0.3 k
% [13, str. 36]. Przypadek algorytmu ewolucyjnego wymaga dłuższego opisu, ponieważ pojęcie to
% jest znacznie szersze od nazw pozostałych metod.


\begin{itemize}
    \item \textbf{Evolutionary Algorithm} - Description
 
    \item \textbf{Hill Climbing} - Description
 
    \item \textbf{Tabu Search} - Description
 
    \item \textbf{Random Search} - Description
 
    \item \textbf{Simulated Annealing} - Description 
\end{itemize}

\section{Particle Swarm Optimization}

\subsection{Description}
Particle Swarm Optimization is an algorithm for optimization of a problem. It iteratively tries to improve a candidate solution 
accordingly to a given measure of quality. PSO have population of particles called swarm and solves problem by moving those particles 
through the search space using formula that involves particle velocity, local best solution and global best solution.

\subsection{Motivation}

\subsection{Implementation}
Expanded structure and modular architecture of MeWeX made simple further extensions of code. 
% To make possible using new algorithm in the same way as already implemented 
% Implementation of PSO 

\subsection{Improvements}







\begin{lstlisting}
Point start()
{
    Timer<ArgumentsType, TimeType> timer(this->mCallPoliciesArguments);

    StepCounter<ArgumentsType, StepType> step(this->mCallPoliciesArguments);
    Report<ArgumentsType, TimeType, StepType> report(this->mCallPoliciesArguments);

    std::vector<Particle> swarm;
    swarm.resize(this->mCallPoliciesArguments.getSwarmSize());
    massMutation(swarm, this->mBest);

    mpEvaluator->evaluate(this->mBest);
    this->mNumberOfEvaluations++;

    double sumVelocity;

    while(!step.isFinished())
    {
        sumVelocity = 0.0;
        for(auto& particle : swarm)
        {
            particle.move(this->mBest);
            mpEvaluator->evaluate(particle);
            if(particle.getLocalBest().getEvaluationPerformance().isGreater(particle.getEvaluationPerformance()))
            {
                particle.setLocalBest(particle);
            }
            if(particle.getEvaluationPerformance().isGreater(this->mBest.getEvaluationPerformance()))
            {
                this->mBest = particle;
            }
            sumVelocity += particle.getVelocityLengthSquared();
            // report.reportStep(step.getCurrentStep(), particle);//TMP!!!!!!
        }
        if((sumVelocity / (double)swarm.size()) < 0.01)
            massMutation(swarm, this->mBest);
        this->mNumberOfEvaluations++;
        report.reportStep(step.getCurrentStep(), this->mBest);
        step.increase();
    }
    report.reportSummary(this->mNumberOfEvaluations, timer.getTime(), this->mBest);

    return this->mBest;
}
\end{lstlisting}




\begin{lstlisting}
namespace machine_learning
{
    namespace heuristic_optimization
    {
        namespace particle_swarm_optimization
        {

template<typename ArgumentsType,
            typename StepType,
            template<typename ArgumentsType, typename StepType> class StepCounter,
            typename TimeType,
            template<typename ArgumentsType, typename TimeType> class Timer,
            template<typename ArgumentsType, typename TimeType, typename StepType> class Report>
class ParticleSwarmOptimization
{
public:
    /**
    * Creates algorithm object with given arguments.
    *
    * @param[in] rStartPoint First, based point.
    * @param[in] pEvaluator Provides a mechanism to evaluate the points.
    * @param[in] rArgs The argument object. Contains the arguments for a call policy.
    */
    ParticleSwarmOptimization(const Point& rStartPoint, Evaluator* pEvaluator, const ArgumentsType& rArgs)
    {
        this->mCallPoliciesArguments = rArgs;
        this->mNumberOfEvaluations = 0;

        this->mBest = rStartPoint;
        this->mpEvaluator = pEvaluator;
    }

    /**
    * An object destructor.
    */
    ~ParticleSwarmOptimization(void) {}

    void massMutation(std::vector<Particle>& swarm, const Point& mBest)
    {
        Particle particle(mBest);
        for(int i = 0;i < this->mCallPoliciesArguments.getSwarmSize();i++)
        {
            particle.setRandomParameters();
            mpEvaluator->evaluate(particle);
            particle.setLocalBest(particle);
            swarm[i] = particle;
        }
    }

    /**
    * Solves the optimization problem. Result of optimization is saved in a file.
    */
    Point start()
    {
        Timer<ArgumentsType, TimeType> timer(this->mCallPoliciesArguments);

        StepCounter<ArgumentsType, StepType> step(this->mCallPoliciesArguments);
        Report<ArgumentsType, TimeType, StepType> report(this->mCallPoliciesArguments);

        std::vector<Particle> swarm;
        swarm.resize(this->mCallPoliciesArguments.getSwarmSize());
        massMutation(swarm, this->mBest);

        mpEvaluator->evaluate(this->mBest);
        this->mNumberOfEvaluations++;

        double sumVelocity;

        while(!step.isFinished())
        {
            sumVelocity = 0.0;
            for(auto& particle : swarm)
            {
                particle.move(this->mBest);
                mpEvaluator->evaluate(particle);
                if(particle.getLocalBest().getEvaluationPerformance().isGreater(particle.getEvaluationPerformance()))
                {
                    particle.setLocalBest(particle);
                }
                if(particle.getEvaluationPerformance().isGreater(this->mBest.getEvaluationPerformance()))
                {
                    this->mBest = particle;
                }
                sumVelocity += particle.getVelocityLengthSquared();
                // report.reportStep(step.getCurrentStep(), particle);//TMP!!!!!!
            }
            if((sumVelocity / (double)swarm.size()) < 0.01)
                massMutation(swarm, this->mBest);
            this->mNumberOfEvaluations++;
            report.reportStep(step.getCurrentStep(), this->mBest);
            step.increase();
        }
        report.reportSummary(this->mNumberOfEvaluations, timer.getTime(), this->mBest);

        return this->mBest;
    }

private:
    ParticleSwarmOptimization(void){}

    Point mBest;
    Evaluator* mpEvaluator;
    int mNumberOfEvaluations;
    ArgumentsType mCallPoliciesArguments;
}; // class ParticleSwarmOptimization


        }
    } // namespace particle_swarm_optimization
} // namespace Optimizer
\end{lstlisting}



\begin{lstlisting}
#include "../BaseCallPoliciesArguments.h"
#include "../Exception/Exception.h"

namespace machine_learning
{
    namespace heuristic_optimization
    {
        namespace particle_swarm_optimization
        {

class CallPoliciesArgumentsPSO : public BaseCallPoliciesArguments
{
public:
    /**
    * Creates object with default values.
    */
    CallPoliciesArgumentsPSO(void);

    /**
    * The object destructor.
    */
    ~CallPoliciesArgumentsPSO(void);

    /**
    * Returns neighbourhood size.
    *
    * @return The neighbourhood size.
    */
    unsigned int getNeighbourhood(void) const;

    /**
    * Returns a value of the radius.
    *
    * @return The value of the radius.
    */
    unsigned int getSwarmSize(void) const;

    /**
    * Reads the characteristic parameters from a .ini <a href="optimizer.cfg">file</a>
    *
    * @param[in] rFileName The config file name.
    *
    * @see BaseCallPoliciesArguments
    */
    void readFromFile(const std::string& rFileName);

private:
    unsigned int mSwarmSize;
    unsigned int mNeighbourhood;

    static const std::string SECTION;
    static const std::string STEPS_KEY;
    static const std::string SWARM_SIZE_KEY;
    static const std::string NEIGHBOURHOOD_KEY;
}; // class CallPoliciesArgumentsPSO


        }
    } // namespace particle_swarm_optimization
} // namespace Optimizer
\end{lstlisting}
    

\begin{lstlisting}
void massMutation(std::vector<Particle>& swarm, const Point& mBest)
{
    Particle particle(mBest);
    for(int i = 0;i < this->mCallPoliciesArguments.getSwarmSize();i++)
    {
        particle.setRandomParameters();
        mpEvaluator->evaluate(particle);
        particle.setLocalBest(particle);
        swarm[i] = particle;
    }
}
\end{lstlisting}



\begin{lstlisting}
#include "../Point.h"


namespace machine_learning
{
	namespace heuristic_optimization
	{
		namespace particle_swarm_optimization
		{


class Particle : public Point
{
public:
    Particle(void);
    ~Particle(void);

    Particle(const Point& rPoint);
    Particle(const Particle& rPoint);
    Particle& operator=(Particle rParticle);
    //bool isEqual(const Point& rPoint);
    void addParameter(const BaseParameter& rParameter);
    void setLocalBest(const Point& rPoint);
    const Point& getLocalBest() const;
    double getVelocityLengthSquared() const;
    void move(const Point& rBest);
    void setRandomParameters(void);
    std::string toString(void) const;

private:
    std::vector<BaseParameter*> mVelocity;
    Point* mBest;
}; // class Particle


		}
	} // namespace particle_swarm_optimization
} // namespace Optimizer
\end{lstlisting}





\begin{lstlisting}
void Particle::move(const Point& rBest)
{
    double c1 = 1.0, c2 = 0.2, c3 = 0.8;
    double r1 = Random::random(), r2 = Random::random(), r3 = Random::random();
    for(int i = 0; i < mVelocity.size(); i++)
    {
        double v,mX,rX,cX;
        auto data = mVelocity[i]->getValueAt(0);
        mVelocity[i]->getValueAt(0).get(v);
        mBest->getParameterAt(i).getValueAt(0).get(mX);
        mParameters[i]->getValueAt(0).get(cX);
        rBest.getParameterAt(i).getValueAt(0).get(rX);
        v = (c1 * r1 * v) + (c2 * r2 * (mX - cX)) + (c2 * r2 * (rX - cX));
        data.set(v);
        mVelocity[i]->setValueAt(0, data);
        data.set(cX + v);
        mParameters[i]->setValueAt(0, data);
    }
}
\end{lstlisting}